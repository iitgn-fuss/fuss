<!DOCTYPE html>
<html lang="en-us" class="m-auto "><head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <link rel="icon" href="/people/subhrajit/favicon.ico" type="image/x-icon" />
  
  <link
    rel="stylesheet"
    href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/all.min.css"
    integrity="sha512-1ycn6IcaQQ40/MKBW2W4Rhis/DbILU74C1vSrLJxCq57o941Ym01SwNsOMqvEBFlcgUa6xLiPY/NS5R+E6ztJQ=="
    crossorigin="anonymous"
    referrerpolicy="no-referrer"
  />
  <link
    rel="stylesheet"
    href="https://cdn.jsdelivr.net/npm/academicons@1.9.1/css/academicons.min.css"
  />
  <link
    rel="stylesheet"
    href="https://fonts.googleapis.com/css2?family=Comfortaa:wght@300;400;500;600;700&display=swap"
  />

  
  
  
  <link
    rel="stylesheet"
    href="/people/subhrajit/main.min.cefafe98c51df1b9e3597f29f0976570d1a5f77b3a5068224564410b1cff9bc8.css"
    integrity="sha256-zvr&#43;mMUd8bnjWX8p8JdlcNGl93s6UGgiRWRBCxz/m8g="
    crossorigin="anonymous"
  />
  
  

  <style>
     
    body, h1, h2, h3, h4, h5, h6, p, span, div, a, li, td, th, 
    input, textarea, button, label, select {
      font-family: 'Comfortaa', cursive !important;
    }
    
     
    i.fas, i.far, i.fab, i.fal, i.fad, i.fa,
    i[class*="fa-"],
    i.ai, i[class*="ai-"],
    .fas::before, .far::before, .fab::before, .fal::before, .fad::before, .fa::before,
    [class*="fa-"]::before,
    .ai::before, [class*="ai-"]::before {
      font-family: "Font Awesome 5 Free", "Font Awesome 5 Brands", "Font Awesome 5 Pro", "Academicons" !important;
      font-weight: inherit !important;
    }
    
     
    .fas, .fas::before {
      font-weight: 900 !important;
    }
    .far, .far::before {
      font-weight: 400 !important;
    }
    .fab, .fab::before {
      font-family: "Font Awesome 5 Brands" !important;
      font-weight: 400 !important;
    }
    
     
    html {
      touch-action: manipulation;
      scroll-behavior: smooth;
    }

    .panel {
      max-height: 0;
      transition: 0.3s ease-out;
    }

    .profile-photo-container {
      img {
        max-width: 100%;
      }
    }
    
     
    .profile-section {
      padding: 1rem;
    }
    
     
    @media (max-width: 1024px) {
      .grid-cols-1.lg\\:grid-cols-5 {
        gap: 1rem !important;
      }
    }
    
    @media (max-width: 768px) {
      body {
        padding: 0.5rem !important;
      }
      
      .profile-section {
        padding: 0.5rem;
        text-align: center;
      }
      
      .profile-section h1 {
        font-size: 1.4rem !important;
        line-height: 1.3;
        margin-bottom: 0.5rem !important;
      }
      
      .profile-section h2 {
        font-size: 1.2rem !important;
        line-height: 1.3;
      }
      
      .profile-section p {
        font-size: 0.85rem !important;
        line-height: 1.4;
        margin-bottom: 0.3rem !important;
      }
      
      .social-icons {
        justify-content: center;
        gap: 1rem;
        flex-wrap: wrap;
      }
      
      .accordion > p {
        padding: 0.75rem !important;
        font-size: 0.95rem !important;
      }
      
      .panel {
        margin-left: 0.5rem !important;
        padding-left: 0.5rem !important;
        padding-right: 0.5rem !important;
      }
    }
    
    @media (max-width: 480px) {
      body {
        padding: 0.25rem !important;
      }
      
      .grid-cols-1.lg\\:grid-cols-5 {
        gap: 0.5rem !important;
      }
      
      .profile-section {
        padding: 0.25rem;
      }
      
      .profile-section h1 {
        font-size: 1.3rem !important;
      }
      
      .profile-section p {
        font-size: 0.8rem !important;
      }
      
      .accordion > p {
        padding: 0.5rem !important;
        font-size: 0.9rem !important;
      }
      
      .accordion > p i {
        font-size: 0.9rem !important;
      }
      
      .social-icons a {
        padding: 0.4rem !important;
        font-size: 1.1rem !important;
      }
    }
     
    .pagefind-ui__search-input {
      color: #1e293b;
      width: 100%;
      padding: 0.75em;
      border-radius: 0.75rem;
      border: 2px solid #0ea5e9;
      background-color: #f8fafc;
      transition: all 0.2s ease;
      font-size: 0.95rem;
    }
    
    .pagefind-ui__search-input:focus {
      outline: none;
      border-color: #0284c7;
      box-shadow: 0 0 0 3px rgba(14, 165, 233, 0.1);
    }
    
    .pagefind-ui__search-clear {
      display: none;
    }
    
    .dark .pagefind-ui__search-input {
      color: #f1f5f9;
      background-color: #334155;
      border-color: #22c55e;
      width: 100%;
      padding: 0.75em;
      border-radius: 0.25em;
      border: 1px solid gray;
    }
    .dark .pagefind-ui__search-input::placeholder {
      color: #8f8f8f;
    }
    .chevron {
      transition: 300ms linear rotate;
    }
    .active > .chevron {
      transform: rotate(90deg);
    }
  </style>

  <script>
    const expandAccordion = (elem) => {
      const allPanels = Array.from(document.querySelectorAll(".panel"));
      const allAccordion = Array.from(document.querySelectorAll(".accordion"));

      if (!elem.parentElement.classList.contains("active")) {
        allAccordion.forEach((acc) => {
          acc.classList.remove("active");
        });
        elem.parentElement.classList.add("active");
        allPanels.forEach(function (elem) {
          elem.style.maxHeight = null;
        });
        let activePanel = elem.parentElement.nextElementSibling;
        if (
          activePanel.id != "skill-panel" &&
          document.querySelector("#skill-panel")
        ) {
          let skillBars = Array.from(
            document.querySelectorAll("#skill-percent")
          );
          skillBars.forEach((elem) => {
            elem.style.width = "0";
          });
        }
        activePanel.style.maxHeight = activePanel.scrollHeight + "px";
      }
    };
  </script>

  <script>
    let html = document.querySelector("html");
    let theme = window.localStorage.getItem("theme");

    const setTheme = (theme) => {
      html.classList.remove("light");
      if (theme === "dark") {
        html.classList.add("dark");
        window.localStorage.setItem("theme", "dark");
      } else {
        html.classList.remove("dark");
        window.localStorage.setItem("theme", "light");
      }
      fixThemeToggleIcon(theme);
    };

    const fixThemeToggleIcon = (theme) => {
      let themeToggle = document.querySelector(".theme-toggle");
      if (themeToggle) {
        if (theme === "dark") {
          themeToggle.classList.remove("fa-moon");
          themeToggle.classList.add("fa-sun");
        } else {
          themeToggle.classList.remove("fa-sun");
          themeToggle.classList.add("fa-moon");
        }
      }
    };

    if (theme == null) {
      if (html.classList.contains("dark")) {
        theme = "dark";
      } else if (html.classList.contains("light")) {
        theme = "light";
      } else {
        const prefersDark = window.matchMedia(
          "(prefers-color-scheme: dark)"
        ).matches;
        if (prefersDark) {
          theme = "dark";
        } else {
          theme = "light";
        }
      }
    }

    setTheme(theme);

    const toggleTheme = () => {
      html.classList.contains("dark") ? setTheme("light") : setTheme("dark");
    };

    window.onload = () => {
      fixThemeToggleIcon(theme);

      let defaultActivePanel = document.querySelector(".accordion.active");
      if (defaultActivePanel) {
        defaultActivePanel.nextElementSibling.style.maxHeight =
          defaultActivePanel.nextElementSibling.scrollHeight + "px";
      }
    };

    window.onresize = () => {
      let defaultActivePanel = document.querySelector(".accordion.active");
      if (defaultActivePanel) {
        defaultActivePanel.nextElementSibling.style.maxHeight =
          defaultActivePanel.nextElementSibling.scrollHeight + "px";
      }
    };
  </script>
</head>
<body class="h-screen p-2 px-4 sm:px-6 lg:px-8 xl:px-12 2xl:px-16 flex flex-col">
    
    <header class="nav flex flex-row row py-3 mb-6 w-full border-b-2 border-transparent bg-gradient-to-r from-transparent via-blue-100/30 to-transparent dark:via-slate-700/30 backdrop-blur-sm shadow-sm justify-between sticky top-0 z-50">
  
  <div class="absolute bottom-0 left-0 right-0 h-0.5 bg-gradient-to-r from-transparent via-blue-400 to-transparent dark:via-cyan-500"></div>
  
  <div class="flex items-center gap-1">
    <a class="nav-menu-item" href="/people/subhrajit/">Home</a>
    <a class="nav-menu-item" href="/people/subhrajit/files/cv_subhrajit.pdf">CV</a>
    <a class="nav-menu-item" href="/people/subhrajit/gallery/">Gallery</a>
  </div>
  
  <div class="flex items-center gap-3">
    
    <div class="relative mr-1 sm:mr-2">
      <button id="search-icon"
         class="w-8 h-8 flex items-center justify-center rounded-full bg-white/80 dark:bg-slate-800/80 border border-gray-200 dark:border-slate-700 text-blue-600 hover:text-blue-800 dark:text-cyan-400 dark:hover:text-cyan-300 hover:shadow-md cursor-pointer text-sm transition-all duration-300"
         onclick="toggleSearch()">
        <i class="fas fa-search"></i>
      </button>
      <input 
        id="search-input" 
        type="text" 
        placeholder="Search..." 
        class="hidden absolute right-0 top-10 w-40 sm:w-48 md:w-56 px-3 py-2 text-sm border-2 border-blue-300 dark:border-cyan-600 rounded-lg bg-white dark:bg-slate-800 text-gray-900 dark:text-gray-100 shadow-lg focus:outline-none focus:ring-2 focus:ring-blue-500 dark:focus:ring-cyan-500"
        onkeypress="handleSearchKeypress(event)"
        onblur="hideSearch()">
    </div>
    
    
    <button
      class="w-8 h-8 flex items-center justify-center rounded-full bg-white/80 dark:bg-slate-800/80 border border-gray-200 dark:border-slate-700 text-blue-600 hover:text-blue-800 dark:text-cyan-400 dark:hover:text-cyan-300 hover:shadow-md cursor-pointer text-sm transition-all duration-300 mr-2 sm:mr-0"
      onclick="toggleTheme()">
      <i class="fas fa-sun theme-toggle"></i>
    </button>
  </div>
</header>



<script>
function toggleSearch() {
  const searchIcon = document.getElementById('search-icon');
  const searchInput = document.getElementById('search-input');
  
  if (searchInput.classList.contains('hidden')) {
    searchInput.classList.remove('hidden');
    searchInput.focus();
    searchIcon.classList.add('text-blue-800', 'dark:text-cyan-300');
  } else {
    searchInput.classList.add('hidden');
    searchIcon.classList.remove('text-blue-800', 'dark:text-cyan-300');
  }
}

function hideSearch() {
  setTimeout(() => {
    const searchInput = document.getElementById('search-input');
    const searchIcon = document.getElementById('search-icon');
    searchInput.classList.add('hidden');
    searchIcon.classList.remove('text-blue-800', 'dark:text-cyan-300');
  }, 100);
}

function handleSearchKeypress(event) {
  if (event.key === 'Enter') {
    const query = event.target.value.trim();
    if (query) {
      
      window.location.href = `\/people\/subhrajit\/search?q=${encodeURIComponent(query)}`;
    }
  }
}
</script>

    
    <main class="grow w-full">
<div class="prose prose-stone dark:prose-invert max-w-none">
<div class="mb-3">
  <h1 class="top-h1">How to Measure Performance of Your Code</h1>
  <p class="mb-1">October 22, 2025</p>
  <p>&mdash;</p>
</div>
<div class="content ">
  <p>Measuring code performance accurately is crucial, especially when optimizing the existing algorithms or designing new ones. In this post, I’ll share my learnings of measuring code performance using various tools and techniques.</p>
<p>For measuring execution time, we can use the following techniques:</p>
<ol>
<li>Wall Clock Time (<code>clock_gettime</code>)</li>
<li>Linux resource usage metrics (<code>getrusage</code>)</li>
</ol>
<p>To measure raw Time Stamp Counter (or, ticks), on x86 architectures we can use:</p>
<ol>
<li><code>RDTSC</code> (Read Time-Stamp Counter)</li>
</ol>
<p>Finally, to pinpoint performance bottlenecks, we can use the Linux <code>perf</code> tool; However, there are two ways to use it:</p>
<ol>
<li><code>perf</code> Command line tool</li>
<li><code>perf_event_open</code> syscall for custom profiling code segments.</li>
</ol>
<p>We will explore each of these methods in detail, with the help of an example C code snippet that we will measure using these techniques.
The naive function snippet we will use for measurement is as follows:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">sum_of_two_arrays</span>(<span style="color:#66d9ef">int</span> <span style="color:#f92672">*</span>array1, <span style="color:#66d9ef">int</span> <span style="color:#f92672">*</span>array2, <span style="color:#66d9ef">int</span> size)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> total_sum <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> sum1 <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>, sum2 <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> size; i<span style="color:#f92672">++</span>)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        sum1 <span style="color:#f92672">+=</span> array1[i];
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> size; i<span style="color:#f92672">++</span>)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        sum2 <span style="color:#f92672">+=</span> array2[i];
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    total_sum <span style="color:#f92672">=</span> sum1 <span style="color:#f92672">+</span> sum2;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> total_sum;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="wall-clock-time-clock_gettime">Wall Clock Time (clock_gettime)</h2>
<p>The most popular way to measure code performance is by using wall clock time. The <a href="https://man7.org/linux/man-pages/man3/clock_gettime.3.html"><code>clock_gettime</code></a> function in Linux provides wall-clock time measurements with nanosecond precision. It can be used to measure the elapsed time for a specific code segment. While there are multiple clock types available, <code>CLOCK_MONOTONIC</code> is generally preferred for measuring elapsed time as it is not affected by system time changes. To use <code>clock_gettime</code>, we have to include the <code>&lt;time.h&gt;</code> header file.</p>
<h3 id="usage">Usage</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">// Include necessary headers and define variables
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">struct</span> timespec start, end;
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">clock_gettime</span>(CLOCK_MONOTONIC, <span style="color:#f92672">&amp;</span>start);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Code segment to measure
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">sum_of_two_arrays</span>(array1, array2, size);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">clock_gettime</span>(CLOCK_MONOTONIC, <span style="color:#f92672">&amp;</span>end);
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">long</span> seconds <span style="color:#f92672">=</span> end.tv_sec <span style="color:#f92672">-</span> start.tv_sec;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">long</span> nanoseconds <span style="color:#f92672">=</span> end.tv_nsec <span style="color:#f92672">-</span> start.tv_nsec;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">double</span> elapsed <span style="color:#f92672">=</span> seconds <span style="color:#f92672">+</span> nanoseconds<span style="color:#f92672">*</span><span style="color:#ae81ff">1e-9</span>;
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;Elapsed time: %.9f seconds</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, elapsed);
</span></span></code></pre></div><h3 id="output">Output</h3>
<pre tabindex="0"><code>Elapsed time: XXX
</code></pre><h2 id="getrusage">getrusage</h2>
<p>In linux systems, <a href="https://www.man7.org/linux/man-pages/man2/getrusage.2.html"><code>getrusage</code></a> is a system call that provides resource usage statistics for the calling process. It is used to measure the resources used by the process, like CPU time, memory usage, etc. We used this system call to measure the CPU time used by our code. POSIX.1 specifies <code>getrusage()</code>, but specifies only the fields <code>ru_utime</code> and <code>ru_stime</code>. And, for our benchmarking purposes, we can use <code>ru_utime</code> and <code>ru_stime</code> to measure the user CPU time and system CPU time, respectively.
The <code>getrusage</code> system call provides information about resource usage for a process, including user and system CPU time. The user CPU time represents the amount of CPU time spent in user mode, while the system CPU time represents the time spent in kernel mode. By measuring the user CPU time before and after executing a code segment, we can determine the CPU time consumed by that segment. To use <code>getrusage</code>, we need to include the <code>&lt;sys/resource.h&gt;</code> header file.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">// Function to measure CPU time in microseconds as a long double
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">inline</span> <span style="color:#66d9ef">long</span> <span style="color:#66d9ef">double</span> <span style="color:#a6e22e">cputime</span>()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">struct</span> rusage rus;
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">getrusage</span>(RUSAGE_SELF, <span style="color:#f92672">&amp;</span>rus);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> rus.ru_utime.tv_sec <span style="color:#f92672">*</span> <span style="color:#ae81ff">1000000.0</span>L <span style="color:#f92672">+</span> rus.ru_utime.tv_usec;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="usage-1">Usage</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>    <span style="color:#75715e">// Include necessary headers and define variables
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">long</span> <span style="color:#66d9ef">double</span> start_time, end_time, cpu_time_used;
</span></span><span style="display:flex;"><span>    start_time <span style="color:#f92672">=</span> <span style="color:#a6e22e">cputime</span>();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Code segment to measure
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">sum_of_two_arrays</span>(array1, array2, size);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    end_time <span style="color:#f92672">=</span> <span style="color:#a6e22e">cputime</span>();
</span></span><span style="display:flex;"><span>    cpu_time_used <span style="color:#f92672">=</span> end_time <span style="color:#f92672">-</span> start_time;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;CPU time used: %.3Lf microseconds</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, cpu_time_used);
</span></span></code></pre></div><h2 id="rdtsc">RDTSC</h2>
<p>On the x86 architecture, the <code>RDTSC</code> (Read Time-Stamp Counter) instruction is a low-level way to measure the number of CPU ticks that have elapsed since the last reset. It provides a raw metric of code execution time, making it suitable for performance profiling. As <code>RDTSC</code> instruction measure the ticks that increments at a constant rate, regardless of CPU frequency scaling (e.g., Turbo Boost, power-saving states), the number of ticks per unit of real time will remain constant, even if the core&rsquo;s clock speed changes.
However, it is well-known that <code>RDTSC</code> does not provide accurate measurements in cases of code cross-contamination due to out-of-order execution. A white paper by Intel that explains how to measure ticks accurately using a combination of <code>CPUID</code>, <code>RDTSC</code>, and <code>RDTSCP</code> instructions. You can find the white paper here: <a href="https://cis.temple.edu/~qzeng/cis3207-spring18/files/ia-32-ia-64-benchmark-code-execution-paper.pdf">How to Benchmark Code Execution Times on Intel® IA-32 and IA-64 Instruction Set Architectures</a>. <code>RDTSCP</code> mitigates some of the out-of-order execution issues by serializing the instruction stream before reading the time-stamp counter.
The reason of using <code>CPUID</code> instruction (which generates an interrupt) before and after <code>RDTSC</code>/<code>RDTSCP</code> is to serialize the instruction stream, ensuring that all previous instructions have completed before reading the time-stamp counter. This helps to get a more accurate measurement of the code segment.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">inline</span> <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> <span style="color:#66d9ef">long</span> <span style="color:#a6e22e">measure_rdtsc_start</span>()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">unsigned</span> cycles_low, cycles_high;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> <span style="color:#66d9ef">long</span> ticks;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">asm</span> <span style="color:#66d9ef">volatile</span>(<span style="color:#e6db74">&#34;CPUID</span><span style="color:#ae81ff">\n\t</span><span style="color:#e6db74">&#34;</span>
</span></span><span style="display:flex;"><span>                 <span style="color:#e6db74">&#34;RDTSC</span><span style="color:#ae81ff">\n\t</span><span style="color:#e6db74">&#34;</span>
</span></span><span style="display:flex;"><span>                 <span style="color:#e6db74">&#34;mov %%edx, %0</span><span style="color:#ae81ff">\n\t</span><span style="color:#e6db74">&#34;</span>
</span></span><span style="display:flex;"><span>                 <span style="color:#e6db74">&#34;mov %%eax, %1</span><span style="color:#ae81ff">\n\t</span><span style="color:#e6db74">&#34;</span> <span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;=r&#34;</span>(cycles_high), <span style="color:#e6db74">&#34;=r&#34;</span>(cycles_low)<span style="color:#f92672">::</span><span style="color:#e6db74">&#34;%rax&#34;</span>, <span style="color:#e6db74">&#34;%rbx&#34;</span>, <span style="color:#e6db74">&#34;%rcx&#34;</span>, <span style="color:#e6db74">&#34;%rdx&#34;</span>);
</span></span><span style="display:flex;"><span>    ticks <span style="color:#f92672">=</span> (((<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> <span style="color:#66d9ef">long</span>)cycles_high <span style="color:#f92672">&lt;&lt;</span> <span style="color:#ae81ff">32</span>) <span style="color:#f92672">|</span> cycles_low);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> ticks;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">// Inline function for measuring rdtscp ticks
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">inline</span> <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> <span style="color:#66d9ef">long</span> <span style="color:#a6e22e">measure_rdtscp_end</span>()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">unsigned</span> cycles_low, cycles_high;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> <span style="color:#66d9ef">long</span> ticks;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">asm</span> <span style="color:#66d9ef">volatile</span>(<span style="color:#e6db74">&#34;RDTSCP</span><span style="color:#ae81ff">\n\t</span><span style="color:#e6db74">&#34;</span>
</span></span><span style="display:flex;"><span>                 <span style="color:#e6db74">&#34;mov %%edx, %0</span><span style="color:#ae81ff">\n\t</span><span style="color:#e6db74">&#34;</span>
</span></span><span style="display:flex;"><span>                 <span style="color:#e6db74">&#34;mov %%eax, %1</span><span style="color:#ae81ff">\n\t</span><span style="color:#e6db74">&#34;</span>
</span></span><span style="display:flex;"><span>                 <span style="color:#e6db74">&#34;CPUID</span><span style="color:#ae81ff">\n\t</span><span style="color:#e6db74">&#34;</span> <span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;=r&#34;</span>(cycles_high), <span style="color:#e6db74">&#34;=r&#34;</span>(cycles_low)<span style="color:#f92672">::</span><span style="color:#e6db74">&#34;%rax&#34;</span>,
</span></span><span style="display:flex;"><span>                               <span style="color:#e6db74">&#34;%rbx&#34;</span>, <span style="color:#e6db74">&#34;%rcx&#34;</span>, <span style="color:#e6db74">&#34;%rdx&#34;</span>);
</span></span><span style="display:flex;"><span>    ticks <span style="color:#f92672">=</span> (((<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> <span style="color:#66d9ef">long</span>)cycles_high <span style="color:#f92672">&lt;&lt;</span> <span style="color:#ae81ff">32</span>) <span style="color:#f92672">|</span> cycles_low);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> ticks;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="usage-2">Usage</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>    <span style="color:#75715e">// Include necessary headers and define variables
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> <span style="color:#66d9ef">long</span> start_ticks, end_ticks, ticks_taken;
</span></span><span style="display:flex;"><span>    start_ticks <span style="color:#f92672">=</span> <span style="color:#a6e22e">measure_rdtsc_start</span>();
</span></span><span style="display:flex;"><span>    sum <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">10000</span>; i<span style="color:#f92672">++</span>)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        sum <span style="color:#f92672">+=</span> <span style="color:#a6e22e">sum_of_two_arrays</span>(array1, array2, N);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    end_ticks <span style="color:#f92672">=</span> <span style="color:#a6e22e">measure_rdtscp_end</span>();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    ticks_taken <span style="color:#f92672">=</span> end_ticks <span style="color:#f92672">-</span> start_ticks;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;Ticks taken: %llu</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, ticks_taken);
</span></span></code></pre></div><h2 id="accuracy-considerations">Accuracy Considerations</h2>
<p>The actual elapsed time will vary based on system load and other factors like CPU frequency scaling, context switching, etc. To get more accurate measurements, consider measuring the code segment multiple times &mdash; create CDF plots to visualize the distribution of execution times or use statistical measures like 95% CI (Confidence Interval) mean to report the results. For execution time measurements, it&rsquo;s also important to minimize the impact of other processes running on the system. Running the measurements on a dedicated machine or using CPU affinity to bind the process to a specific core can help reduce variability.</p>
<p>I personally prefer averaging strategy of GMPBench to report the mean execution time of a given function. What it does is, it starts with a single iteration of the function and doubles the number of iterations until the total elapsed time exceeds a predefined threshold (e.g., 250 ms). Once the threshold is reached, it calculates the average time per iteration by dividing the total elapsed time by the number of iterations. This approach helps to ensure that the measurements are less affected by transient system load variations. Further, based on this computed mean time, it calculates throughput (operations per second) and reports that as the final performance metric.</p>
<p>Originally, GMPBench was designed to benchmark arbitrary-precision arithmetic operations in the GMP library, but the underlying methodology can be applied to measure the performance of any function or code segment.</p>
<p>Below you can find three different adapted macros of GMPBench style averaging strategy to measure execution time using <code>clock_gettime</code>, <code>RDTSC</code>, and <code>getrusage</code> respectively.</p>
<p>Whenever I report timing numbers, I prefer to run the GMPBench style averaging strategy for 20-30 times and report the 95% CI mean of the execution time or throughput numbers.</p>
<h2 id="linux-perf">Linux perf</h2>
<p>The &lsquo;perf&rsquo; tool in Linux is a powerful performance analysis tool that can measure various aspects of code performance, including CPU cycles, cache misses, and more. It provides a wealth of information but can be complex to use effectively.</p>
<p>In conclusion, accurately measuring code performance requires a combination of tools and techniques. By understanding the strengths and weaknesses of each method, you can gain valuable insights into your code&rsquo;s performance and identify areas for optimization.</p>

</div>
</div>
<div class="flex flex-row justify-around my-2">
  <h3 class="mb-1 mt-1 text-left mr-4">
    
    <a
      href="/people/subhrajit/posts/autovectorize-your-code/"
      title=""
    >
      <i class="nav-menu fas fa-chevron-circle-left"></i>
    </a>
    
  </h3>
  <h3 class="mb-1 mt-1 text-left ml-4">
    
    <i class="text-blue-300 dark:text-slate-500 fas fa-chevron-circle-right"></i>
    
  </h3>
</div>


    </main>
    
    <footer class="text-xs text-center ">
  <div class="max-w-4xl mx-auto px-4">
    
    
    <p class="markdownify text-gray-600 dark:text-gray-400 font-light mb-2 leading-relaxed">
      © subhrajit | powered by <a href="https://gohugo.io/">hugo</a> and <a href="https://github.com/darshanbaral/aafu">aafu</a>
    </p>
    
    
  </div>
</footer>

    
  </body>
</html>
